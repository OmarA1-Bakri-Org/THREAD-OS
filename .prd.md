# PRD: ThreadOS — Thread-Based Engineering Runtime + Horizontal Sequence UI + Chat Orchestrator (Windows-first) powered by mprocs

## 1) Executive summary

ThreadOS is a **local-first, Windows-first “Thread Runtime”** that enables engineers (and an LLM orchestrator) to **create, run, and manage Thread-Based Engineering workloads** (Base / P / C / F / B / L) with strong auditability and safety controls.

ThreadOS combines:

* **mprocs** as the terminal process runner (“thread panes”) to run multiple commands in parallel, show each output separately, and allow interaction with running processes. ([GitHub][1])
* A **horizontal Sequence UI** (left → right) that represents steps (threads), lanes (parallelism), dependencies, gates, and fused results.
* A deterministic **control surface** (`seqctl` CLI + optional local HTTP API) that an LLM orchestrator can safely manipulate (create steps, reorder, run, parallelize, gate, fuse) without GUI automation.
* A lightweight **runner wrapper** per step that standardizes prompts, logging, status, and artifact collection.

Runtime dependency: **mprocs for Windows** has been provided as `/mnt/data/mprocs.exe` and will be vendored into the product build.

---

## 2) Background and problem

Agentic engineering is difficult to scale because teams lack:

1. A consistent **unit of work** (“thread”) with an explicit lifecycle (prompt/plan → agent tool calls → review/validation).
2. A repeatable way to **scale compute** (parallelism, fusion, orchestration) without UI chaos (many terminals, scattered logs, unclear ownership).
3. A control plane that an **LLM orchestrator** can reliably manipulate without brittle GUI automation or non-auditable side effects.

mprocs addresses the operational foundation by running **multiple commands in parallel**, showing per-process output, and supporting interactive terminals. ([GitHub][1]) It also supports **remote control over TCP** using a `--server` listener and `--ctl` commands encoded as YAML. ([GitHub][2])

ThreadOS layers a **sequence model, deterministic controls, and auditability** on top of mprocs so Base/P/C/F/B/L threads are reproducible, reviewable, and safe.

---

## 3) Goals and non-goals

### 3.1 Goals

* Provide a **horizontal Sequence UI** to represent steps, lanes, dependencies, fan-out/merge, and gates.
* Provide an **LLM-addressable** CLI/API to create/modify sequences and control execution deterministically.
* Use **mprocs** as the execution UI and process manager, leveraging:

  * Local vs global config and a project-local `mprocs.yaml`. ([GitHub][2])
  * Remote control via `--server` and `--ctl`, including commands such as `add-proc`, `duplicate-proc`, `start-proc`, `restart-proc`, `send-key`, and `batch`. ([GitHub][2])
* Standardize **artifacts**: per-step prompt, logs, status, summaries, and diffs.
* Add a **Chat Orchestrator** interface: natural language → structured actions → diff preview → explicit apply (SAFE mode).

### 3.2 Non-goals (v1)

* Cloud multi-user collaboration / shared remote sessions.
* Replacing Claude Code / Codex / Gemini; ThreadOS wraps/invokes these tools.
* Detach/reattach multiplexer semantics; mprocs is intentionally not tmux-like in persistence. ([GitHub][2])
* Fully autonomous “Z-thread” zero-touch production deployments in v1 (supported later once trust, validation loops, and governance mature).

---

## 4) Target users / personas

1. **Principal/Staff Engineer (primary)**: needs structured multi-thread workflows, rapid prototyping via fusion, and high-confidence results.
2. **Agentic Engineer (daily)**: operates P/F/L threads to accelerate delivery; wants low friction and clear review points.
3. **LLM Orchestrator (automation actor)**: manipulates sequences and runs steps via deterministic CLI/API with enforced guardrails.

---

## 5) Product concept

### 5.1 Key concepts

* A **Sequence** is a repo-local YAML/JSON plan describing a graph of **Steps** and dependencies.
* Each **Step** maps to one or more **mprocs processes**, each running a standardized runner command.
* ThreadOS adds deterministic **edit/run semantics** and **auditability** around what is otherwise an ad-hoc multi-terminal workflow.

### 5.2 Why mprocs

mprocs is purpose-built to run a predictable set of commands repeatedly in a single terminal UI, with separate outputs and interactive input support. ([GitHub][1]) It supports local/global configuration and remote control, which is crucial for LLM-safe orchestration. ([GitHub][2])

---

## 6) Scope: components and deliverables

### A) Sequence definition (source of truth)

* File: `.threados/sequence.yaml` (repo-local)
* Defines steps, lanes/roles, dependencies, gates, fanout, model selection, and artifacts.

### B) Horizontal Sequence UI

* Horizontal canvas (left → right), parallel lanes (rows)
* Step inspection, editing, grouping (P), fusion creation (F), gate insertion (C)
* Controls: run runnable, run/stop/restart step, approve gate, open logs, open diff

### C) Control plane (LLM-friendly)

* `seqctl` CLI (required)
* Optional local HTTP API (recommended for UI + chat; can be implemented in v1 or v1.1 depending on delivery plan)

### D) Runtime adapter for mprocs

* Launch mprocs with a server listener (`--server` or config `server:`). ([GitHub][2])
* Issue remote commands using `mprocs --ctl '{c: ...}'`. ([GitHub][2])

### E) Step runner wrappers

* Standardizes:

  * prompt ingestion (file path)
  * model selection (claude/codex/gemini)
  * logging to `.threados/runs/<runId>/...`
  * step status files (start/end, exit code, artifacts)

### F) Chat Orchestrator UI

* Natural language → structured actions (JSON) → diff preview → explicit apply/execute (SAFE mode)

---

## 7) Thread types → sequence primitives (functional mapping)

### 7.1 Base Thread

* Representation: one step (`type: base`)
* Execution: one mprocs process invoking runner

### 7.2 P-thread (parallel / repeat)

* Representation: group step with `fanout: N`, `mode: throughput|repeat`
* Execution: N mprocs processes (optionally via `duplicate-proc`) ([GitHub][2])

### 7.3 C-thread (chained phases + checkpoints)

* Representation: multiple dependent steps with explicit gate nodes
* Execution: next phase can only start after gate approval (SAFE)

### 7.4 F-thread (fusion)

* Representation: parallel candidate steps + synth step that depends on all candidates
* Execution: run candidates, then synth runner fuses outputs/logs

### 7.5 B-thread (big/orchestrated)

* Representation: one orchestrator step that spawns substeps (internally or via actions)
* Execution: orchestrator uses `seqctl`/API to create/start substeps, then finalizes

### 7.6 L-thread (long autonomy)

* Representation: a long-run step with optional watchdog/verifier companion
* Execution: long-running agent process + optional verifier process visible in mprocs

---

## 8) User stories and key flows

### Flow 1: Base thread

Create → run → review artifacts → mark done.

### Flow 2: P-thread (repeat-for-confidence)

Parallelize a prompt to N workers → compare outputs → select/fuse.

### Flow 3: C-thread (high-risk migration)

Create phased plan → run phase 1 → gate approval → run phase 2 → gate approval → finalize.

### Flow 4: F-thread rapid prototyping

Run Claude/Codex/Gemini candidates → synth step merges best approach → generate patch + tests.

### Flow 5: B-thread orchestrator

Run orchestrator → spawns planner/builder/reviewer/verifier → final report → apply.

### Flow 6: L-thread long run

Start autonomous run → watchdog verifies continuously → user returns to review summary/diff.

### Flow 7: Chat-driven creation

User asks in chat → orchestrator proposes actions + diff → user applies → run runnable.

---

## 9) Functional requirements

### 9.1 Sequence model and storage

* Directory: `.threados/`

  * `sequence.yaml`
  * `runs/<runId>/...`
  * `state/` (mprocs mapping, last known statuses)
  * `audit.log` (append-only)
* Step fields:

  * `id`, `name`, `type`
  * `lane` (optional label), `role` (optional)
  * `cwd` (workspace/worktree)
  * `model` (claude-code | codex | gemini)
  * `prompt_file`
  * `depends_on[]`
  * `status` (READY/RUNNING/NEEDS_REVIEW/DONE/FAILED/BLOCKED)
  * `artifacts[]`

### 9.2 Editing operations (UI + CLI)

* Create/edit/delete steps
* Reorder steps (subject to dependency constraints)
* Add/remove dependencies
* Create parallel groups (P)
* Create fusion structures (F)
* Insert gates and approve gates (C)
* Clone step and optionally allocate new workspace/worktree

### 9.3 Execution operations (UI + CLI)

* Run step
* Run group
* Run runnable frontier
* Stop/kill step
* Restart step
* Select/focus step in mprocs (best-effort)
* Send-key (advanced; gated by policy)

mprocs remote control supports `start-proc`, `term-proc`, `kill-proc`, `restart-proc`, `select-proc`, `send-key`, and `batch`. ([GitHub][2])

### 9.4 mprocs session management

* Config layering:

  * Global config location includes a Windows path under Roaming. ([GitHub][2])
  * Local config `mprocs.yaml` in current directory overrides global. ([GitHub][2])
* Process configuration:

  * Each process must provide exactly one of `shell` or `cmd` and may specify `cwd`, `env`, `autostart`, `autorestart`, `scrollback`. ([GitHub][2])
* Remote control:

  * Enable via `server: 127.0.0.1:4050` or CLI `mprocs --server ...` ([GitHub][2])
  * Send commands via `mprocs --ctl '{c: ...}'` ([GitHub][2])
* Lifecycle constraint:

  * When mprocs exits, the processes it runs end as well (no detach/reattach semantics). ([GitHub][2])

### 9.5 Prompt management

* `.threados/prompts/<stepId>.md`
* Templates per thread type (Base/P/C/F/B/L)
* “Generate prompt from template” action in UI

### 9.6 Artifacts and logging (runner-level)

Runner writes:

* `runs/<runId>/<stepId>/stdout.log`
* `runs/<runId>/<stepId>/stderr.log`
* `runs/<runId>/<stepId>/status.json`
* `runs/<runId>/<stepId>/summary.md` (optional)
* `runs/<runId>/<stepId>/diff.patch` (optional) or references to git diff

### 9.7 Chat Orchestrator requirements

* Orchestrator must output **structured actions** (JSON) mapping to `seqctl`
* SAFE mode defaults:

  * propose only; explicit user confirmation required to apply/run
  * destructive actions require extra confirmation
* Chat must always show:

  * proposed actions card
  * diff preview for `sequence.yaml` changes
  * Apply / Apply & Run / Discard controls

---

## 10) Non-functional requirements

### 10.1 Platform

* Windows-first (PowerShell + Windows Terminal compatible)
* Bun/Next.js front-end baseline (shadcn UI)
* mprocs binary vendored

### 10.2 Reliability

* No loss of run artifacts
* UI crash does not lose sequence state (file-first)
* If mprocs fails, steps are marked BLOCKED/FAILED with error context

### 10.3 Security and safety

* Command allowlist for runner
* Workspace allowlist (restrict `cwd`)
* Secrets redaction in logs
* SAFE/POWER policy modes with explicit gating for destructive operations

### 10.4 Performance

* Support 20–50 concurrent processes without UI lockup (mprocs handles terminal rendering; UI must poll efficiently)
* UI should remain responsive for sequences with 100+ nodes (virtualization where necessary)

---

## 11) Technical architecture

### 11.1 High-level components

1. **Sequence Engine**

   * Parse/write `.threados/sequence.yaml`
   * Validate DAG (no cycles)
   * Compute runnable frontier
2. **Runtime Controller**

   * Launch mprocs (server-enabled)
   * Issue `--ctl` commands (YAML-encoded) ([GitHub][2])
3. **Runner**

   * Wraps agent CLI (claude-code/codex/gemini)
   * Writes logs + status deterministically
4. **UI**

   * Horizontal canvas + inspector + chat
   * Calls local API or shells out to `seqctl`
5. **Audit subsystem**

   * Append-only audit entries for changes and executions

### 11.2 Process identity mapping

* Maintain mapping:

  * Step ID → mprocs process index/id (best-effort)
* Persist in `.threados/state/mprocs-map.json`
* Reconcile on startup (process list may differ)

### 11.3 API endpoints (if HTTP API enabled)

* `POST /chat` (stream)
* `POST /actions/validate`
* `POST /actions/apply`
* `POST /run` / `POST /stop` / `POST /restart`
* `GET /sequence` / `GET /status`

---

## 12) UX requirements (horizontal + chat)

### 12.1 UX principles

* **Left-to-right progression**, lanes for parallelism, statuses at a glance, dependencies unambiguous.

### 12.2 Layout

* **Main canvas**: horizontal timeline grid

  * X-axis: logical time/order
  * Y-axis: lanes/roles
* Panels:

  * Top bar (Run runnable, policy SAFE/POWER, search)
  * Left rail optional (templates/history)
  * Right inspector (step details)
  * Right-docked chat panel (collapsible)

### 12.3 Step cards

Must display: type badge, status chip, model, workspace, quick actions.

### 12.4 Connectors and lanes

* Solid arrow = hard dependency
* Dashed arrow = soft dependency (future)
* Lanes represent parallel branches; optional lane headers for intent.

### 12.5 Horizontal representations

* Base: single node
* P: fan-out
* C: left-to-right with gates
* F: fan-out then merge
* B: orchestrator spawning subthreads
* L: extended-width long-run node + optional watchdog lane

### 12.6 Interactions

* Horizontal pan/scroll, optional mini-map
* Drag left/right reorder (dependency-safe)
* Drag up/down lane organization
* Drag handles to create dependencies
* Group as Parallel; Create Fusion; Insert Gate
* Run runnable frontier

### 12.7 Chat interaction model

* Natural language request → structured actions + diff → explicit apply/run
* No “agent clicks UI”; only actions/seqctl-driven execution

---

## 13) CLI spec (`seqctl`) — required

### 13.1 Design principles

* Deterministic JSON I/O
* Exit codes consistent
* Non-interactive by default

### 13.2 Commands (v1)

* `seqctl init`
* `seqctl step add|edit|rm|clone`
* `seqctl dep add|rm`
* `seqctl group parallelize`
* `seqctl fusion create`
* `seqctl gate insert|approve`
* `seqctl run step|group|runnable|all`
* `seqctl stop|restart step`
* `seqctl status [--watch]`
* `seqctl mprocs open|select`

---

## 14) Implementation details (Windows-first)

### 14.1 mprocs binary

* Support `THREADOS_MPROCS_PATH`
* Default vendored path: `./vendor/mprocs/windows/mprocs.exe`
* Installer copies `/mnt/data/mprocs.exe` into vendor directory (or packages it)

### 14.2 Shell strategy

* Prefer `cmd: ["exe", "args"]` for Windows robustness (avoid quoting pitfalls of `shell:`). ([GitHub][2])

### 14.3 UI baseline

* Bun + Next.js + shadcn
* Theme install command is standardized and tracked in setup docs (execution details belong in implementation plan, not core requirements)

---

## 15) Security / policy system (must-have)

* `policy.yaml` per repo:

  * allowed commands
  * forbidden patterns
  * allowed workspaces/cwd roots
  * maximum fanout
  * actions requiring confirmation
* SAFE mode:

  * orchestrator cannot apply/run without explicit user action
  * destructive ops require extra confirmation

---

## 16) Observability and “agentic growth” metrics

Track per-run:

* Threads created/day
* Average duration
* Fanout usage (P/F)
* Fusion agreement rate (heuristic)
* Human checkpoints per sequence (C)
* Failure/restart rates

---

## 17) Testing plan

### Unit

* sequence parse/write
* DAG validation
* policy enforcement
* template expansion

### Integration (Windows)

* Start mprocs with `--server`, verify control plane operations using `--ctl`. ([GitHub][2])
* Validate runner artifacts (status.json/logs) and state reconciliation.

### E2E

* Base, P, C (gates), F (merge), B (orchestrator scaffolding), L (long run) flows.

---

## 18) Rollout and milestones

* M0: repo scaffolding, `seqctl init`, sequence schema
* M1: mprocs runtime controller (server + ctl operations) ([GitHub][2])
* M2: runner wrappers + artifact standardization
* M3: thread templates (Base/P/C/F/B/L)
* M4: horizontal Sequence UI + inspector
* M5: chat orchestrator + diff/confirm + audit log
* M6 (optional): mini-map, soft deps, richer synthesis tooling

---

## 19) Risks and mitigations

1. **mprocs finite lifetime**: processes end when mprocs ends. ([GitHub][2])
   Mitigation: treat mprocs as the active session; rely on artifacts for continuity.
2. **Windows quoting complexity**
   Mitigation: prefer `cmd` arrays; centralize command building.
3. **LLM-driven destructive actions**
   Mitigation: SAFE mode by default, allowlists, explicit confirmations, audit trail.
4. **State desync between UI and runtime**
   Mitigation: file-first truth; runner status + reconciliation.

---

## 20) Acceptance criteria (Definition of Done)

1. Users can create and run **Base/P/C/F/B/L** from UI and `seqctl`.
2. mprocs launches and displays processes; ThreadOS can control it via `--server`/`--ctl` for required operations. ([GitHub][2])
3. Every step produces durable artifacts: prompt, stdout/stderr logs, status.json, optional summary/diff.
4. SAFE mode prevents destructive operations without explicit confirmation.
5. Chat orchestration works end-to-end: natural language → proposed actions → diff preview → apply/run, fully auditable.

---

## Appendix A: mprocs capabilities ThreadOS relies on

* Runs multiple commands in parallel, shows separate outputs, interactive terminals. ([GitHub][1])
* Global vs local config and Windows global config location; local overrides global. ([GitHub][2])
* Process config schema: `shell` vs `cmd`, plus `cwd`, `env`, `autostart`, `autorestart`, `scrollback`. ([GitHub][2])
* Remote control: server via config/CLI and YAML-encoded ctl commands with a defined command set. ([GitHub][2])
* Finite lifetime semantics vs tmux: when mprocs ends, processes end.

[1]: https://github.com/pvolok/mprocs?utm_source=chatgpt.com "pvolok/mprocs: Run multiple commands in parallel"
[2]: https://raw.githubusercontent.com/pvolok/mprocs/v0.7.2/README.md "raw.githubusercontent.com"
